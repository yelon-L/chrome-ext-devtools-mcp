<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MCP SSE æµ‹è¯•</title>
  <style>
    body { font-family: monospace; padding: 20px; max-width: 1200px; margin: 0 auto; }
    h1 { color: #333; }
    .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
    button { padding: 10px 20px; margin: 5px; cursor: pointer; font-size: 14px; }
    button.primary { background: #007bff; color: white; border: none; border-radius: 4px; }
    button.primary:hover { background: #0056b3; }
    pre { background: #f5f5f5; padding: 10px; border-radius: 4px; overflow-x: auto; }
    .log { max-height: 400px; overflow-y: auto; }
    .success { color: green; }
    .error { color: red; }
    .info { color: blue; }
  </style>
</head>
<body>
  <h1>ğŸ§ª Chrome DevTools MCP - SSE æµ‹è¯•é¡µé¢</h1>
  
  <div class="section">
    <h2>çŠ¶æ€</h2>
    <p>ä¼šè¯ID: <span id="sessionId">æœªè¿æ¥</span></p>
    <p>è¿æ¥çŠ¶æ€: <span id="status">æœªè¿æ¥</span></p>
  </div>

  <div class="section">
    <h2>æ“ä½œ</h2>
    <button class="primary" onclick="connect()">1. è¿æ¥ SSE</button>
    <button class="primary" onclick="initialize()">2. åˆå§‹åŒ–</button>
    <button class="primary" onclick="listExtensions()">3. æµ‹è¯• list_extensions</button>
    <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
  </div>

  <div class="section">
    <h2>ç»“æœ</h2>
    <div id="result"></div>
  </div>

  <div class="section">
    <h2>æ—¥å¿—</h2>
    <pre id="log" class="log"></pre>
  </div>

  <script>
    let eventSource = null;
    let sessionId = null;
    let messageId = 1;
    const pendingRequests = new Map();

    function log(msg, type = 'info') {
      const logEl = document.getElementById('log');
      const time = new Date().toLocaleTimeString();
      logEl.textContent += `[${time}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function connect() {
      if (eventSource) {
        log('å·²ç»è¿æ¥', 'error');
        return;
      }

      log('æ­£åœ¨è¿æ¥ SSE...', 'info');
      eventSource = new EventSource('/sse');

      eventSource.addEventListener('endpoint', (e) => {
        const data = JSON.parse(e.data);
        sessionId = new URL(data.uri, location.href).searchParams.get('sessionId');
        document.getElementById('sessionId').textContent = sessionId;
        document.getElementById('status').textContent = 'âœ… å·²è¿æ¥';
        log('âœ… SSE è¿æ¥æˆåŠŸ, ä¼šè¯ID: ' + sessionId, 'success');
      });

      eventSource.addEventListener('message', (e) => {
        const msg = JSON.parse(e.data);
        log('ğŸ“¥ æ”¶åˆ°: ' + JSON.stringify(msg).substring(0, 100), 'info');
        
        if (msg.id && pendingRequests.has(msg.id)) {
          const {resolve} = pendingRequests.get(msg.id);
          pendingRequests.delete(msg.id);
          resolve(msg.result);
        }
      });

      eventSource.onerror = (e) => {
        log('âŒ SSE é”™è¯¯', 'error');
        document.getElementById('status').textContent = 'âŒ æ–­å¼€';
      };
    }

    async function sendRequest(method, params = {}) {
      if (!sessionId) {
        alert('è¯·å…ˆè¿æ¥ SSE');
        return null;
      }

      const id = messageId++;
      const message = {
        jsonrpc: '2.0',
        id,
        method,
        params,
      };

      log('ğŸ“¤ å‘é€: ' + method, 'info');

      const res = await fetch(`/message?sessionId=${sessionId}`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(message),
      });

      if (!res.ok) {
        log('âŒ è¯·æ±‚å¤±è´¥: ' + res.status, 'error');
        return null;
      }

      return new Promise((resolve) => {
        pendingRequests.set(id, {resolve});
        setTimeout(() => {
          if (pendingRequests.has(id)) {
            pendingRequests.delete(id);
            resolve(null);
            log('â° è¯·æ±‚è¶…æ—¶', 'error');
          }
        }, 10000);
      });
    }

    async function initialize() {
      const result = await sendRequest('initialize', {
        protocolVersion: '2024-11-05',
        capabilities: {},
        clientInfo: {name: 'web-test', version: '1.0.0'},
      });

      if (result) {
        log('âœ… åˆå§‹åŒ–æˆåŠŸ: ' + result.serverInfo.name, 'success');
      }
    }

    async function listExtensions() {
      const startTime = Date.now();
      
      const result = await sendRequest('tools/call', {
        name: 'list_extensions',
        arguments: {},
      });

      const duration = Date.now() - startTime;

      if (result) {
        const text = result.content[0]?.text || '';
        const count = (text.match(/##/g) || []).length - 1;
        
        log(`âœ… list_extensions å®Œæˆ (è€—æ—¶: ${duration}ms)`, 'success');
        log(`   æ‰¾åˆ° ${count} ä¸ªæ‰©å±•`, 'success');
        
        const hasHelper = text.includes('MCP Service Worker Activator');
        const hasSW = text.includes('Service Worker:');
        
        log(`   Helper Extension: ${hasHelper ? 'âœ…' : 'âŒ'}`, hasHelper ? 'success' : 'error');
        log(`   SW çŠ¶æ€æ˜¾ç¤º: ${hasSW ? 'âœ…' : 'âŒ'}`, hasSW ? 'success' : 'error');
        
        document.getElementById('result').innerHTML = '<pre>' + text.substring(0, 1000) + '</pre>';
      } else {
        log('âŒ list_extensions å¤±è´¥', 'error');
      }
    }

    function clearLog() {
      document.getElementById('log').textContent = '';
    }

    // è‡ªåŠ¨æç¤º
    log('ğŸ‘‹ æ¬¢è¿ï¼è¯·æŒ‰é¡ºåºç‚¹å‡»æŒ‰é’®ï¼š', 'info');
    log('   1. è¿æ¥ SSE', 'info');
    log('   2. åˆå§‹åŒ–', 'info');
    log('   3. æµ‹è¯• list_extensions', 'info');
  </script>
</body>
</html>
